{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Which algorithms should I use?","text":"<p>Personal note of programming algorithms and data structures.</p> <ul> <li> <p>Two pointers </p> <p></p> <p>Left and right pointers, sliding window and fast-slow pointers.</p> <p> Problem characteristics</p> </li> <li> <p>Recursion </p> <p></p> <p>Recursion, backtracking and divide-and-conquer.</p> <p> Problem characteristics</p> </li> <li> <p>Dynamic programming </p> <p></p> <p>Dynamic programming, memoization and tabulation.</p> <p> Problem characteristics</p> </li> <li> <p>Greedy </p> <p></p> <p>The greedy algorithm.</p> <p> Problem characteristics</p> </li> </ul>"},{"location":"dynamic-programming/","title":"Dynamic programming","text":"<p>Quote</p> <p>\u201cThere are only two hard things in Computer Science: cache invalidation and naming things.\u201d \u2014 Phil Karlton</p> <p>Note</p> <p>A work in progress, check back later for more content.</p>"},{"location":"greedy/","title":"Greedy","text":"<p>Quote</p> <p>\u201cWe should forget about small efficiencies, say about 97% of the time: premature optimization is the root of all evil.\u201d \u2014 Donald Knuth</p> <p>Note</p> <p>A work in progress, check back later for more content.</p>"},{"location":"recursion/","title":"Recursion","text":"<p>Quote</p> <p>\u201cIn order to understand recursion, one must first understand recursion.\u201d \u2014 Anonymous</p> <p>Note</p> <p>A work in progress, check back later for more content.</p>"},{"location":"two-pointers/","title":"Two pointers","text":"<p>Quote</p> <p>\u201cAlgorithmic complexity for structured programmers: All algorithms are \\(\\boldsymbol{O(f(n))}\\), where \\(\\boldsymbol{f}\\) is someone else's responsibility.\u201d \u2014 Peter Cooper</p> <p>Make use of two pointers to solve problems that require traversing a sequence of elements.</p> <p>Common problems:</p> <ul> <li>Two Sum</li> <li>Container With Most Water</li> <li>Trapping Rain Water</li> </ul> GroovyJavaJavaScriptKotlinPythonTypeScript <pre><code>int[] twoSum(int[] nums, int target) {\n    for (var i = 0; i &lt; nums.length; i++) {\n        for (var j = i + 1; j &lt; nums.length; j++) {\n            if (nums[j] == target - nums[i]) {\n                return new int[]{i, j}\n            }\n        }\n    }\n    return []\n}\n</code></pre> <pre><code>int[] twoSum(int[] nums, int target) {\n    for (int i = 0; i &lt; nums.length; i++) {\n        for (int j = i + 1; j &lt; nums.length; j++) {\n            if (nums[j] == target - nums[i]) {\n                return new int[]{i, j};\n            }\n        }\n    }\n    return null;\n}\n</code></pre> <pre><code>function twoSum(nums, target) {\n  for (let i = 0; i &lt; nums.length; i++) {\n    const complement = target - nums[i];\n    if (nums.slice(i + 1).includes(complement)) {\n      return [i, nums.indexOf(complement, i + 1)];\n    }\n  }\n  return undefined;\n}\n</code></pre> <pre><code>fun twoSum(nums: IntArray, target: Int): IntArray {\n    for (i in nums.indices) {\n        for (j in i + 1 until nums.size) {\n            if (nums[j] == target - nums[i]) {\n                return intArrayOf(i, j)\n            }\n        }\n    }\n    return intArrayOf()\n}\n</code></pre> <pre><code>def two_sum(self, nums: list[int], target: int) -&gt; list[int] | None:\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in nums[i + 1:]:\n            return [i, nums.index(complement, i + 1)]\n    return None\n</code></pre> <pre><code>function twoSum(nums: number[], target: number): number[] {\n  for (let i = 0; i &lt; nums.length; i++) {\n    const complement = target - nums[i];\n    if (nums.slice(i + 1).includes(complement)) {\n      return [i, nums.indexOf(complement, i + 1)];\n    }\n  }\n  return undefined;\n}\n</code></pre> <p></p>"},{"location":"two-pointers/#sliding-window","title":"Sliding window","text":"<p>Restrict the range of the two pointers to a certain window size or condition.</p> <p>Common problems:</p> <ul> <li>Longest Substring Without Repeating Characters</li> <li>Minimum Window Substring</li> <li>Sliding Window Maximum</li> </ul> GroovyJavaJavaScriptKotlinPythonTypeScript <pre><code>int lengthOfLongestSubstring(String s) {\n    HashSet&lt;Character&gt; characters = []\n    var start = 0\n    var end = 0\n    var maxLength = Integer.MIN_VALUE\n    while (end &lt; s.length()) {\n        if (characters.add(s.charAt(end))) {\n            maxLength = Math.max(maxLength, characters.size())\n            end++\n            continue\n        }\n        characters.remove(s.charAt(start))\n        start++\n    }\n    return maxLength\n}\n</code></pre> <pre><code>int lengthOfLongestSubstring(String s) {\n    Set&lt;Character&gt; characters = new HashSet&lt;&gt;();\n    int start = 0;\n    int end = 0;\n    int maxLength = Integer.MIN_VALUE;\n    while (end &lt; s.length()) {\n        if (characters.add(s.charAt(end))) {\n            maxLength = Math.max(maxLength, characters.size());\n            end++;\n            continue;\n        }\n        characters.remove(s.charAt(start));\n        start++;\n    }\n    return maxLength;\n}\n</code></pre> <pre><code>function lengthOfLongestSubstring(s) {\n    const characters = new Set();\n    let start = 0;\n    let end = 0;\n    let maxLength = Number.MIN_SAFE_INTEGER;\n    while (end &lt; s.length) {\n      if (!characters.has(s[end])) {\n        characters.add(s[end]);\n        end++;\n        maxLength = Math.max(maxLength, characters.size);\n        continue;\n      }\n      characters.delete(s[start]);\n      start++;\n    }\n    return maxLength;\n  }\n</code></pre> <pre><code>fun lengthOfLongestSubstring(s: String): Int {\n    val characters = hashSetOf&lt;Char&gt;()\n    var start = 0\n    var end = 0\n    var maxLength = Int.MIN_VALUE\n    while (end &lt; s.length) {\n        if (characters.add(s[end])) {\n            maxLength = max(maxLength, characters.size)\n            end++\n            continue\n        }\n        characters -= s[start]\n        start++\n    }\n    return maxLength\n}\n</code></pre> <pre><code>def length_of_longest_substring(self, s: str) -&gt; int:\n    characters = set()\n    start = 0\n    end = 0\n    max_length = -maxsize\n    while end &lt; len(s):\n        if s[end] not in characters:\n            characters.add(s[end])\n            end += 1\n            max_length = max(max_length, len(characters))\n            continue\n        characters.remove(s[start])\n        start += 1\n</code></pre> <pre><code>function lengthOfLongestSubstring(s: string): number {\n    const characters = new Set&lt;string&gt;();\n    let start = 0;\n    let end = 0;\n    let maxLength = Number.MIN_SAFE_INTEGER;\n    while (end &lt; s.length) {\n      if (!characters.has(s[end])) {\n        characters.add(s[end]);\n        end++;\n        maxLength = Math.max(maxLength, characters.size);\n        continue;\n      }\n      characters.delete(s[start]);\n      start++;\n    }\n    return maxLength;\n  }\n</code></pre> <p></p>"},{"location":"two-pointers/#fast-slow-pointers","title":"Fast-slow pointers","text":"<p>Pointers that move at different speeds to find a cycle or a specific condition.</p> <p>Common problems:</p> <ul> <li>Linked List Cycle</li> <li>Sort List</li> <li>Reorder List</li> </ul> GroovyJavaJavaScriptKotlinPythonTypeScript <pre><code>boolean hasCycle(SinglyListNode head) {\n    var slow = head.next\n    var fast = head.next.next\n    while (fast != null &amp;&amp; fast.hasNext() &amp;&amp; slow != fast) {\n        slow = slow.next\n        fast = fast.next.next\n    }\n    return slow == fast\n}\n</code></pre> <pre><code>boolean hasCycle(ListNode head) {\n    SinglyListNode slow = head.next;\n    SinglyListNode fast = head.next.next;\n    while (fast != null &amp;&amp; fast.hasNext() &amp;&amp; slow != fast) {\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n    return slow == fast;\n}\n</code></pre> <pre><code>function hasCycle(head) {\n  let slow = head.next;\n  let fast = head.next.next;\n  while (fast &amp;&amp; fast.hasNext() &amp;&amp; slow !== fast) {\n    slow = slow.next;\n    fast = fast.next.next;\n  }\n  return slow === fast;\n}\n</code></pre> <pre><code>fun hasCycle(head: SinglyListNode?): Boolean {\n    if (head?.next == null) {\n        return false\n    }\n    var slow = head.next\n    var fast = head.next!!.next\n    while (fast != null &amp;&amp; fast.hasNext() &amp;&amp; slow !== fast) {\n        slow = slow!!.next\n        fast = fast.next!!.next\n    }\n    return slow === fast\n}\n</code></pre> <pre><code>def has_cycle(self, head: ListNode) -&gt; bool:\n    slow = head.next\n    fast = head.next.next\n    while fast and fast.next and slow != fast:\n        slow = slow.next\n        fast = fast.next.next\n    return slow == fast\n</code></pre> <pre><code>function hasCycle(head: SinglyListNode | undefined): boolean {\n  let slow = head.next;\n  let fast = head.next.next;\n  while (fast &amp;&amp; fast.hasNext() &amp;&amp; slow !== fast) {\n    slow = slow.next;\n    fast = fast.next.next;\n  }\n  return slow === fast;\n}\n</code></pre> <p></p>"},{"location":"two-pointers/#problem-characteristics","title":"Problem characteristics","text":"<ul> <li> The data structure is linear</li> <li> The task is to find more than one element</li> </ul>"},{"location":"data-structures/","title":"Data structures","text":"<ul> <li> <p>Lists</p> <p></p> <p>Array, list or any indexed collection of elements.</p> <p> Which one to use?</p> </li> <li> <p>Queues</p> <p></p> <p>Queue, stack or any FIFO or LIFO collection of elements.</p> <p> Which one to use?</p> </li> <li> <p>Sets</p> <p></p> <p>Set or any collection of unique elements.</p> <p> Which one to use?</p> </li> <li> <p>Maps</p> <p></p> <p>Map, dictionary or any collection of key-value pairs.</p> <p> Which one to use?</p> </li> </ul>"},{"location":"data-structures/#performance-overview","title":"Performance overview","text":"Data structure Access Search Insert Delete Lists \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {\u0398(1)}\\) \u2192 \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{black} \\fcolorbox{gold}{yellow} {\u0398(n)}\\) \u2192 \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\) \\(\\color{black} \\fcolorbox{gold}{yellow} {\u0398(n)}\\) \u2192 \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\) \\(\\color{black} \\fcolorbox{gold}{yellow} {\u0398(n)}\\) \u2192 \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\) Queues \\(\\color{black} \\fcolorbox{gold}{yellow} {\u0398(n)}\\) \u2192 \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\) \\(\\color{black} \\fcolorbox{gold}{yellow} {\u0398(n)}\\) \u2192 \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {\u0398(1)}\\) \u2192 \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {\u0398(1)}\\) \u2192 \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) Sets \\(\\color{black} \\fcolorbox{gold}{yellow} {\u0398(n)}\\) \u2192 \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\) \\(\\color{black} \\fcolorbox{gold}{yellow} {\u0398(n)}\\) \u2192 \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {\u0398(1)}\\) \u2192 \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {\u0398(1)}\\) \u2192 \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) Maps \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {\u0398(1)}\\) \u2192 \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {\u0398(1)}\\) \u2192 \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {\u0398(1)}\\) \u2192 \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {\u0398(1)}\\) \u2192 \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\)"},{"location":"data-structures/lists/","title":"Lists","text":"<p>Quote</p> <p>\u201cShould array indices start at 0 or 1? My compromise of 0.5 was rejected without, I thought, proper consideration.\u201d \u2014 Stan Kelly-Bootle</p> JavaPython Operation ArrayList  LinkedList  CopyOnWriteArrayList  Add \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\) Remove \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\) Get \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) Contains \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\) \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\) \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\) Next \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) Operation list  Copy \\(\\color{black} \\fcolorbox{gold}{yellow} {\u0398(n)}\\) \u2192 \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\) Append \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {\u0398(1)}\\) \u2192 \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) Pop last \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {\u0398(1)}\\) \u2192 \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) Pop intermediate \\(\\color{black} \\fcolorbox{gold}{yellow} {\u0398(n)}\\) \u2192 \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\) Insert \\(\\color{black} \\fcolorbox{gold}{yellow} {\u0398(n)}\\) \u2192 \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\) Get item \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {\u0398(1)}\\) \u2192 \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) Set item \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {\u0398(1)}\\) \u2192 \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) Delete item \\(\\color{black} \\fcolorbox{gold}{yellow} {\u0398(n)}\\) \u2192 \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\) Iteration \\(\\color{black} \\fcolorbox{gold}{yellow} {\u0398(n)}\\) \u2192 \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\) Get slice \\(\\color{black} \\fcolorbox{yellowgreen}{greenyellow} {\u0398(k)}\\) \u2192 \\(\\color{black} \\fcolorbox{yellowgreen}{greenyellow} {O(k)}\\) Del slice \\(\\color{black} \\fcolorbox{gold}{yellow} {\u0398(n)}\\) \u2192 \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\) Set slice \\(\\color{black} \\fcolorbox{yellowgreen}{greenyellow} {\u0398(k + n)}\\) \u2192 \\(\\color{black} \\fcolorbox{yellowgreen}{greenyellow} {O(k + n)}\\) Extend \\(\\color{black} \\fcolorbox{yellowgreen}{greenyellow} {\u0398(k)}\\) \u2192 \\(\\color{black} \\fcolorbox{yellowgreen}{greenyellow} {O(k)}\\) Sort \\(\\color{black} \\fcolorbox{yellowgreen}{greenyellow} {\u0398(log(n))}\\) \u2192 \\(\\color{black} \\fcolorbox{yellowgreen}{greenyellow} {O(log(n))}\\) Multiply \\(\\color{black} \\fcolorbox{yellowgreen}{greenyellow} {\u0398(n . k)}\\) \u2192 \\(\\color{black} \\fcolorbox{yellowgreen}{greenyellow} {O(n . k)}\\) <code>x in s</code> \\(\\color{black} \\fcolorbox{gold}{yellow} {\u0398(n)}\\) <code>mins(s)</code>, <code>max(s)</code> \\(\\color{black} \\fcolorbox{gold}{yellow} {\u0398(n)}\\) Get length \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {\u0398(1)}\\) \u2192 \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) <p>Lists are a collection of elements that can be accessed by their index.</p> GroovyJavaJavaScriptKotlinPythonTypeScript <pre><code>var empty = Collections.emptyList()\nvar singleton = Collections.singletonList(1)\nvar list = [1, 2, 3]\nvar unmodifiableList = Collections.unmodifiableList(arrayList)\n</code></pre> <pre><code>List&lt;Integer&gt; empty = Collections.emptyList();\nList&lt;Integer&gt; singleton = Collections.singletonList(1);\nList&lt;Integer&gt; list = new ArrayList&lt;&gt;(Arrays.asList(1, 2, 3));\nList&lt;Integer&gt; unmodifiableList = Collections.unmodifiableList(arrayList);\n</code></pre> <pre><code>const list = [1, 2, 3];\nconst unmodifiableList = Object.freeze(list);\n</code></pre> <pre><code>val empty = emptyList&lt;Int&gt;()\nval singleton = listOf(1)\nval list = mutableListOf(1, 2, 3)\nval unmodifiableList = listOf(1, 2, 3)\n</code></pre> <pre><code>l = [1, 2, 3]\nunmodifiable_list = tuple(l)\n</code></pre> <pre><code>const list: number[] = [1, 2, 3];\nconst unmodifiableList: readonly number[] = Object.freeze(list);\n</code></pre> <pre><code>block-beta\n  columns 2\n  block:indices\n    columns 1\n    i1(\"0\") i2(\"1\") i3(\"2\") i4(\"3\")\n  end\n  block:nums\n    columns 1\n    v1[\"3\"] v2[\"6\"] v3[\"5\"] v4[\"8\"]\n  end\n\n  i1 --&gt; v1\n  i2 --&gt; v2\n  i3 --&gt; v3\n  i4 --&gt; v4\n\nstyle indices fill:transparent</code></pre>"},{"location":"data-structures/lists/#which-one-to-use","title":"Which one to use?","text":"<ul> <li> ArrayList is the fastest to iterate.</li> <li> Use LinkedList when elements are frequently modified.</li> </ul>"},{"location":"data-structures/maps/","title":"Maps","text":"<p>Quote</p> <p>\u201cBad programmers worry about the code. Good programmers worry about data structures and their relationships.\u201d \u2014 Linus Torvalds</p> JavaPython Operation HashMap  LinkedHashMap  IdentityHashMap  WeakHashMap  EnumMap  TreeMap  ConcurrentHashMap  ConcurrentSkipListMap  Get \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{black} \\fcolorbox{yellowgreen}{greenyellow} {O(log(n))}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{black} \\fcolorbox{yellowgreen}{greenyellow} {O(log(n))}\\) Contains \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{black} \\fcolorbox{yellowgreen}{greenyellow} {O(log(n))}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{black} \\fcolorbox{yellowgreen}{greenyellow} {O(log(n))}\\) Next \\(\\color{black} \\fcolorbox{yellowgreen}{greenyellow} {O(h / n)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{black} \\fcolorbox{yellowgreen}{greenyellow} {O(h / n)}\\) \\(\\color{black} \\fcolorbox{yellowgreen}{greenyellow} {O(h / n)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{black} \\fcolorbox{yellowgreen}{greenyellow} {O(log(n))}\\) \\(\\color{black} \\fcolorbox{yellowgreen}{greenyellow} {O(h / n)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) Operation dict  <code>k in d</code> \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {\u0398(1)}\\) \u2192 \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\) Copy \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\) Get item \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {\u0398(1)}\\) \u2192 \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\) Set item \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {\u0398(1)}\\) \u2192 \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\) Delete item \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {\u0398(1)}\\) \u2192 \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\) Iteration \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\) <p>Maps are a collection of key-value pairs.</p> GroovyJavaJavaScriptKotlinPythonTypeScript <pre><code>var map = [\n    5: 1,\n    10: 2,\n    20: 3,\n]\n\nvar unmodifiableMap = Collections.unmodifiableMap(map)\n</code></pre> <pre><code>Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();\nmap.put(1, 2);\nmap.put(2, 3);\nmap.put(3, 4);\n\nMap&lt;Integer, Integer&gt; unmodifiableMap = Collections.unmodifiableMap(map);\n</code></pre> <pre><code>const map =\n    new Map([\n        [5, 1],\n        [10, 2],\n        [20, 3],\n    ]);\n</code></pre> <pre><code>val map =\n    mutableMapOf(\n        5 to 1,\n        10 to 2,\n        20 to 3\n    )\n\nval unmodifiableMap = map.toMap()\n</code></pre> <pre><code>map = {\n    5: 1,\n    10: 2,\n    20: 3,\n}\n</code></pre> <pre><code>const map =\n    new Map&lt;number, number&gt;([\n        [5, 1],\n        [10, 2],\n        [20, 3],\n    ]);\n</code></pre> <pre><code>block-beta\n  columns 2\n  block:keys\n    columns 1\n    k1[\"5\"] k2[\"10\"] k3[\"15\"] k4[\"20\"]\n  end\n  block:vals\n    columns 1\n    v1[\"3\"] v2[\"6\"] v3[\"5\"] v4[\"8\"]\n  end\n\n  k1 --&gt; v1\n  k2 --&gt; v2\n  k3 --&gt; v3\n  k4 --&gt; v4</code></pre>"},{"location":"data-structures/maps/#which-one-to-use","title":"Which one to use?","text":"<ul> <li> HashMap is the fastest to iterate.</li> <li> Use LinkedHashMap when the insertion order matters.</li> <li> Use TreeMap when the natural order matters.</li> <li> Use WeakHashMap for in-memory caching.</li> <li> Use ConcurrentHashMap for thread-safe operations.</li> </ul>"},{"location":"data-structures/queues/","title":"Queues","text":"<p>Quote</p> <p>\u201cIt is better to have 100 functions operate on one data structure than to have 10 functions operate on 10 data structures.\u201d \u2014 Alan Perlis</p> JavaPython Operation PriorityQueue  LinkedList  ArrayDequeue  ConcurrentLinkedQueue  ArrayBlockingQueue  PriorityBlockingQueue  SynchronousQueue DelayQueue  LinkedBlockingQueue  Offer \\(\\color{black} \\fcolorbox{yellowgreen}{greenyellow} {O(log(n))}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{black} \\fcolorbox{yellowgreen}{greenyellow} {O(log(n))}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{black} \\fcolorbox{yellowgreen}{greenyellow} {O(log(n))}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) Peek \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) Poll \\(\\color{black} \\fcolorbox{yellowgreen}{greenyellow} {O(log(n))}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{black} \\fcolorbox{yellowgreen}{greenyellow} {O(log(n))}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{black} \\fcolorbox{yellowgreen}{greenyellow} {O(log(n))}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) Remove \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\) \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\) \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\) \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\) \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\) \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\) \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\) Size \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) Operation collections.deque  Copy \\(\\color{black} \\fcolorbox{gold}{yellow} {\u0398(n)}\\) \u2192 \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\) Append \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {\u0398(1)}\\) \u2192 \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) Append left \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {\u0398(1)}\\) \u2192 \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) Pop \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {\u0398(1)}\\) \u2192 \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) Pop left \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {\u0398(1)}\\) \u2192 \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) Extend \\(\\color{black} \\fcolorbox{yellowgreen}{greenyellow} {\u0398(k)}\\) \u2192 \\(\\color{black} \\fcolorbox{yellowgreen}{greenyellow} {O(k)}\\) Extend left \\(\\color{black} \\fcolorbox{yellowgreen}{greenyellow} {\u0398(k)}\\) \u2192 \\(\\color{black} \\fcolorbox{yellowgreen}{greenyellow} {O(k)}\\) Rotate \\(\\color{black} \\fcolorbox{yellowgreen}{greenyellow} {\u0398(k)}\\) \u2192 \\(\\color{black} \\fcolorbox{yellowgreen}{greenyellow} {O(k)}\\) Remove \\(\\color{black} \\fcolorbox{gold}{yellow} {\u0398(n)}\\) \u2192 \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\) Get length \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {\u0398(1)}\\) \u2192 \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) <p>Queues are a type of data structure that follow the FIFO (First In First Out) principle.</p> GroovyJavaKotlinPython <pre><code>Queue&lt;Integer&gt; queue = []\nqueue &lt;&lt; 1\nqueue &lt;&lt; 2\nqueue &lt;&lt; 3\n</code></pre> <pre><code>Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();\nqueue.add(1);\nqueue.add(2);\nqueue.add(3);\n</code></pre> <pre><code>val queue = LinkedList&lt;Int&gt;()\nqueue += 1\nqueue += 2\nqueue += 3\n</code></pre> <pre><code>from collections import deque\n\nqueue = deque(1, 2, 3)\n</code></pre> <pre><code>block-beta\n  columns 2\n  block:indices\n    columns 1\n    top(\"top\") space:2 bottom(\"bottom\")\n  end\n  block:nums\n    columns 1\n    v1[\"3\"] v2[\"6\"] v3[\"5\"] v4[\"8\"]\n  end\n\n  top --&gt; v1\n  bottom --&gt; v4\n\nstyle indices fill:transparent</code></pre>"},{"location":"data-structures/queues/#which-one-to-use","title":"Which one to use?","text":"<ul> <li> Use LinkedList when the insertion order matters.</li> <li> Use PriorityQueue when the natural order matters.</li> </ul>"},{"location":"data-structures/sets/","title":"Sets","text":"<p>Quote</p> <p>\u201cSmart data structures and dumb code works a lot better than the other way around.\u201d \u2014 Eric S. Raymond</p> JavaPython Operation HashSet  LinkedHashSet  EnumSet  TreeSet  CopyOnWriteArraySet  ConcurrentSkipListSet  Add \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{black} \\fcolorbox{yellowgreen}{greenyellow} {O(log(n))}\\) \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\) \\(\\color{black} \\fcolorbox{yellowgreen}{greenyellow} {O(log(n))}\\) Remove \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{black} \\fcolorbox{yellowgreen}{greenyellow} {O(log(n))}\\) \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\) \\(\\color{black} \\fcolorbox{yellowgreen}{greenyellow} {O(log(n))}\\) Contains \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{black} \\fcolorbox{yellowgreen}{greenyellow} {O(log(n))}\\) \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\) \\(\\color{black} \\fcolorbox{yellowgreen}{greenyellow} {O(log(n))}\\) Next \\(\\color{black} \\fcolorbox{yellowgreen}{greenyellow} {O(h / n)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{black} \\fcolorbox{yellowgreen}{greenyellow} {O(log(n))}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) Size \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\) Operation set  <code>x in s</code> \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {\u0398(1)}\\) \u2192 \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\) Union <code>s|t</code> \\(\\color{black} \\fcolorbox{gold}{yellow} {\u0398(len(s) + len(t))}\\) Intersection <code>s&amp;t</code> \\(\\color{black} \\fcolorbox{gold}{yellow} {\u0398(min(len(s), len(t)))}\\) \u2192 \\(\\color{black} \\fcolorbox{darkorange}{sandybrown} {O(len(s) . len(t))}\\) Multiple intersection <code>s1&amp;s2&amp;...&amp;sn</code> \\(\\color{black} \\fcolorbox{darkorange}{sandybrown} {(n - 1) . O(l)}\\)\\(\\small{\\textsf{where} l = \\mathtt{max}(\\mathtt{len}(s1), \\ldots, \\mathtt{len}(sn))}\\) Difference <code>s-t</code> \\(\\color{black} \\fcolorbox{gold}{yellow} {\u0398(len(s))}\\) <code>s.difference_update(t)</code> \\(\\color{black} \\fcolorbox{gold}{yellow} {\u0398(len(t))}\\) Symmetric Difference <code>s^t</code> \\(\\color{black} \\fcolorbox{gold}{yellow} {\u0398(len(s))}\\) \u2192 \\(\\color{black} \\fcolorbox{darkorange}{sandybrown} {O(len(s) . len(t))}\\) <code>s.symmetric_difference_update(t)</code> \\(\\color{black} \\fcolorbox{gold}{yellow} {\u0398(len(t))}\\) \u2192 \\(\\color{black} \\fcolorbox{darkorange}{sandybrown} {O(len(s) . len(t))}\\) <p>Sets are a collection of unique elements.</p> GroovyJavaJavaScriptKotlinPythonTypeScript <pre><code>var empty = Collections.emptySet()\nSet&lt;Integer&gt; set = [1, 2, 3]\nvar unmodifiableSet = Collections.unmodifiableSet(set)\n</code></pre> <pre><code>Set&lt;Integer&gt; empty = Collections.emptySet();\nSet&lt;Integer&gt; set = new HashSet&lt;&gt;();\nSet&lt;Integer&gt; unmodifiableSet = Collections.unmodifiableSet(set);\n</code></pre> <pre><code>const set = new Set([1, 2, 3]);\n</code></pre> <pre><code>val empty = emptySet&lt;Int&gt;()\nval set = mutableSetOf(1, 2, 3)\nval unmodifiableSet = setOf(1, 2, 3)\n</code></pre> <pre><code>s = set(1, 2, 3)\nunmodifiable_set = frozenset([1, 2, 3])\n</code></pre> <pre><code>const set = new Set&lt;number&gt;([1, 2, 3]);\n</code></pre> <pre><code>block-beta\n  columns 2\n  block:indices\n    columns 1\n    space:3 current(\"current\")\n  end\n  block:nums\n    columns 1\n    v1[\"3\"] v2[\"6\"] v3[\"5\"] v4[\"8\"]\n  end\n\n  current --&gt; v4\n\nstyle indices fill:transparent</code></pre>"},{"location":"data-structures/sets/#which-one-to-use","title":"Which one to use?","text":"<ul> <li> HashSet is the fastest to iterate.</li> <li> Use LinkedHashSet when the insertion order matters.</li> <li> Use TreeSet when the natural order matters.</li> </ul>"},{"location":"references/","title":"References","text":"<ol> <li> Big-O Cheat Sheet <p>This webpage covers the space and time Big-O complexities of common algorithms used in Computer Science.</p> </li> <li> Python Wiki: TimeComplexity <p>This page documents the time-complexity (aka \"Big O\" or \"Big Oh\") of various operations in current CPython.</p> </li> </ol>"},{"location":"searching/","title":"Searching","text":"<ul> <li> <p>Linear search </p> <p></p> <p>Sequentially checks each element of the list until a match is found</p> <p> Use cases</p> </li> <li> <p>Binary search </p> <p></p> <p>Compares the target value to the middle element of the array, eliminating half of the search range each iteration.</p> <p> Use cases</p> </li> <li> <p>Depth-first search </p> <p></p> <p>Explores as far as possible along each branch before backtracking.</p> <p> Use cases</p> </li> <li> <p>Breadth-first search </p> <p></p> <p>Explores all nodes at the present depth prior to moving on to the nodes at the next depth level.</p> <p> Use cases</p> </li> </ul>"},{"location":"searching/#performance-overview","title":"Performance overview","text":"Search Time complexity Space complexity Linear search \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {\u03a9(1)}\\) \u2192 \\(\\color{black} \\fcolorbox{gold}{yellow} {\u0398(n)}\\) \u2192 \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) Binary search \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {\u03a9(1)}\\) \u2192 \\(\\color{black} \\fcolorbox{yellowgreen}{greenyellow} {\u0398(log(n))}\\) \u2192 \\(\\color{black} \\fcolorbox{yellowgreen}{greenyellow} {O(log(n))}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) Breadth-first search \\(\\color{black} \\fcolorbox{gold}{yellow} {\u0398(\u2502E\u2502 + \u2502V\u2502)}\\) \\(\\color{black} \\fcolorbox{gold}{yellow} {\u0398(\u2502V\u2502)}\\) Depth-first search \\(\\color{black} \\fcolorbox{gold}{yellow} {\u0398(\u2502E\u2502 + \u2502V\u2502)}\\) \\(\\color{black} \\fcolorbox{gold}{yellow} {\u0398(\u2502V\u2502)}\\)"},{"location":"searching/binary-search/","title":"Binary search","text":"<p>Quote</p> <p>\u201cPerfection is achieved, not when there is nothing more to add, but when there is nothing left to take away.\u201d \u2014 Antoine de Saint Exup\u00e9ry</p> Case Time complexity Space complexity Best \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {\u03a9(1)}\\) Average \\(\\color{black} \\fcolorbox{yellowgreen}{greenyellow} {\u0398(log(n))}\\) Worst \\(\\color{black} \\fcolorbox{yellowgreen}{greenyellow} {O(log(n))}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) <p>Binary search or logarithmic search, finds the center position to divide the array into two halves.</p> GroovyJavaKotlinJavaScriptPythonTypeScript <pre><code>int binarySearch(int[] array, int target, int start, int end) {\n    while (start &lt;= end) {\n        var center = start + (end - start) / 2\n        if (target == array[center]) {\n            return center\n        }\n        if (target &gt; array[center]) {\n            start = center + 1\n        } else {\n            end = center - 1\n        }\n    }\n    return -1\n}\n</code></pre> <pre><code>int binarySearch(int array[], int target, int start, int end) {\n    while (start &lt;= end) {\n        int center = start + (end - start) / 2;\n        if (target == array[center]) {\n            return center;\n        }\n        if (target &gt; array[center]) {\n            start = center + 1;\n        } else {\n            end = center - 1;\n        }\n    }\n    return -1;\n}\n</code></pre> <pre><code>fun binarySearch(array: IntArray, target: Int, start: Int, end: Int): Int {\n    while (start &lt;= end) {\n        val center = start + (end - start) / 2\n        if (target == array[center]) {\n            return center\n        }\n        if (target &gt; array[center]) {\n            start = center + 1\n        } else {\n            end = center - 1\n        }\n    }\n    return -1\n}\n</code></pre> <pre><code>function binarySearch(array, target, start, end) {\n    while (start &lt;= end) {\n        const center = start + Math.floor((end - start) / 2);\n        if (target === array[center]) {\n            return center;\n        }\n        if (target &gt; array[center]) {\n            start = center + 1;\n        } else {\n            end = center - 1;\n        }\n    }\n    return -1;\n}\n</code></pre> <pre><code>def binary_search(array, target, start, end):\n    while start &lt;= end:\n        center = start + (end - start) // 2\n        if target == array[center]:\n            return center\n        if target &gt; array[center]:\n            start = center + 1\n        else:\n            end = center - 1\n    return -1\n</code></pre> <pre><code>function binarySearch(array: number[], target: number, start: number, end: number): number {\n    while (start &lt;= end) {\n        const center = start + Math.floor((end - start) / 2);\n        if (target === array[center]) {\n            return center;\n        }\n        if (target &gt; array[center]) {\n            start = center + 1;\n        } else {\n            end = center - 1;\n        }\n    }\n    return -1;\n}\n</code></pre> <p></p>"},{"location":"searching/binary-search/#use-cases","title":"Use cases","text":"<ul> <li> The list is sorted.</li> </ul>"},{"location":"searching/breadth-first-search/","title":"Breadth-first search","text":"<p>Quote</p> <p>\u201cJust because something is easy to measure doesn't mean it's important.\u201d \u2014 David Heinemeier Hansson</p> Case Time complexity Space complexity Worst \\(\\color{black} \\fcolorbox{gold}{yellow} {\u0398(\u2502E\u2502 + \u2502V\u2502)}\\) \\(\\color{black} \\fcolorbox{gold}{yellow} {\u0398(\u2502V\u2502)}\\) <p>Note</p> <p>A work in progress, check back later for more content.</p>"},{"location":"searching/depth-first-search/","title":"Depth-first search","text":"<p>Quote</p> <p>\u201cMost of the biggest problems in software are problems of misconception.\u201d \u2014 Rich Hickey</p> Case Time complexity Space complexity Worst \\(\\color{black} \\fcolorbox{gold}{yellow} {\u0398(\u2502E\u2502 + \u2502V\u2502)}\\) \\(\\color{black} \\fcolorbox{gold}{yellow} {\u0398(\u2502V\u2502)}\\) <p>Note</p> <p>A work in progress, check back later for more content.</p>"},{"location":"searching/linear-search/","title":"Linear search","text":"<p>Quote</p> <p>\u201cWhen in doubt, use brute force.\u201d \u2014 Ken Thompson</p> Case Time complexity Space complexity Best \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {\u03a9(1)}\\) Average \\(\\color{black} \\fcolorbox{gold}{yellow} {\u0398(n)}\\) Worst \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) <p>Linear search or sequential search, iterates through each element until item is found.</p> GroovyJavaKotlinJavaScriptPythonTypeScript <pre><code>int linearSearch(int[] array, int target) {\n    for (var i = 0; i &lt; array.length; i++) {\n        if (array[i] == target) {\n            return i\n        }\n    }\n    return -1\n}\n</code></pre> <pre><code>int linearSearch(int array[], int target) {\n    for (int i = 0; i &lt; array.length; i++) {\n        if (array[i] == target) {\n            return i;\n        }\n    }\n    return -1;\n}\n</code></pre> <pre><code>fun linearSearch(array: IntArray, target: Int): Int {\n    for (i in array.indices) {\n        if (array[i] == target) {\n            return i\n        }\n    }\n    return -1\n}\n</code></pre> <pre><code>function linearSearch(array, target) {\n  for (let i = 0; i &lt; array.length; i++) {\n    if (array[i] === target) {\n      return i;\n    }\n  }\n  return -1;\n}\n</code></pre> <pre><code>def linear_search(array: list[int], target: int) -&gt; int:\n    for i in range(len(array)):\n        if array[i] == target:\n            return i\n    return -1\n</code></pre> <pre><code>function linearSearch(array: number[], target: number): number {\n  for (let i = 0; i &lt; array.length; i++) {\n    if (array[i] === target) {\n      return i;\n    }\n  }\n  return -1;\n}\n</code></pre> <p></p>"},{"location":"searching/linear-search/#use-cases","title":"Use cases","text":"<ul> <li> The list to search is small</li> </ul>"},{"location":"sorting/","title":"Sorting","text":"<ul> <li> <p>Selection sort </p> <p></p> <p>Selection sort is an in-place comparison sorting algorithm.</p> <p> Use cases</p> </li> <li> <p>Bubble sort </p> <p></p> <p>Repeatedly steps through the input list element by element, comparing the current element with the one after it, swapping their values if needed.</p> <p> Use cases</p> </li> <li> <p>Insertion sort </p> <p></p> <p>Builds the final sorted array (or list) one item at a time by comparisons.</p> <p> Use cases</p> </li> <li> <p>Merge sort </p> <p></p> <p>Efficient, general-purpose, and comparison-based sorting algorithm.</p> <p> Use cases</p> </li> <li> <p>Quicksort </p> <p></p> <p>Slightly faster than merge sort and heapsort for randomized data, particularly on larger distributions.</p> <p> Use cases</p> </li> <li> <p>Heapsort </p> <p></p> <p>Reorganizes an input array into a heap (a data structure where each node is greater than its children) and then repeatedly removes the largest node from that heap, placing it at the end of the array.</p> <p> Use cases</p> </li> </ul>"},{"location":"sorting/#performance-overview","title":"Performance overview","text":"Sort Time complexity Space complexity Selection sort \\(\\color{white} \\fcolorbox{crimson}{firebrick} {\u03a9(n^2)}\\) \u2192 \\(\\color{white} \\fcolorbox{crimson}{firebrick} {\u0398(n^2)}\\) \u2192 \\(\\color{white} \\fcolorbox{crimson}{firebrick} {O(n^2)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) Bubble sort \\(\\color{black} \\fcolorbox{gold}{yellow} {\u03a9(n)}\\) \u2192 \\(\\color{white} \\fcolorbox{crimson}{firebrick} {\u0398(n^2)}\\) \u2192 \\(\\color{white} \\fcolorbox{crimson}{firebrick} {O(n^2)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) Insertion sort \\(\\color{black} \\fcolorbox{gold}{yellow} {\u03a9(n)}\\) \u2192 \\(\\color{white} \\fcolorbox{crimson}{firebrick} {\u0398(n^2)}\\) \u2192 \\(\\color{white} \\fcolorbox{crimson}{firebrick} {O(n^2)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) Merge sort \\(\\color{black} \\fcolorbox{darkorange}{sandybrown} {\u03a9(n . log(n))}\\) \u2192 \\(\\color{black} \\fcolorbox{darkorange}{sandybrown} {\u0398(n . log(n))}\\) \u2192 \\(\\color{black} \\fcolorbox{darkorange}{sandybrown} {O(n . log(n))}\\) \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\) Quicksort \\(\\color{black} \\fcolorbox{darkorange}{sandybrown} {\u03a9(n . log(n))}\\) \u2192 \\(\\color{black} \\fcolorbox{darkorange}{sandybrown} {\u0398(n . log(n))}\\) \u2192 \\(\\color{white} \\fcolorbox{crimson}{firebrick} {O(n^2)}\\) \\(\\color{black} \\fcolorbox{yellowgreen}{greenyellow} {O(log(n))}\\) Heapsort \\(\\color{black} \\fcolorbox{darkorange}{sandybrown} {\u03a9(n . log(n))}\\) \u2192 \\(\\color{black} \\fcolorbox{darkorange}{sandybrown} {\u0398(n . log(n))}\\) \u2192 \\(\\color{black} \\fcolorbox{darkorange}{sandybrown} {O(n . log(n))}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\)"},{"location":"sorting/bubble-sort/","title":"Bubble sort","text":"<p>Quote</p> <p>\u201cSimplicity is hard to build, easy to use, and hard to charge for. Complexity is easy to build, hard to use, and easy to charge for.\u201d \u2014 Chris Sacca</p> Case Time complexity Space complexity Best \\(\\color{black} \\fcolorbox{gold}{yellow} {\u03a9(n)}\\) Average \\(\\color{white} \\fcolorbox{crimson}{firebrick} {\u0398(n^2)}\\) Worst \\(\\color{white} \\fcolorbox{crimson}{firebrick} {O(n^2)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) <p>Bubble sort or sinking sort, is better than selection sort but more complex than insertion sort.</p> <p>Note</p> <p>A work in progress, check back later for more content.</p>"},{"location":"sorting/heapsort/","title":"Heapsort","text":"<p>Quote</p> <p>\u201cAlgorithm: A word used by programmers when\u2026 they don\u2019t want to explain what they did.\u201d \u2014 Dave Smith</p> Case Time complexity Space complexity Best \\(\\color{black} \\fcolorbox{darkorange}{sandybrown} {\u03a9(n . log(n))}\\) Average \\(\\color{black} \\fcolorbox{darkorange}{sandybrown} {\u0398(n . log(n))}\\) Worst \\(\\color{black} \\fcolorbox{darkorange}{sandybrown} {O(n . log(n))}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) <p>Reorganizes the data into a heap structure to sort it.</p> <p>Note</p> <p>A work in progress, check back later for more content.</p>"},{"location":"sorting/insertion-sort/","title":"Insertion sort","text":"<p>Quote</p> <p>\u201cProgram construction consists of a sequence of refinement steps.\u201d \u2014 Niklaus Wirth</p> Case Time complexity Space complexity Best \\(\\color{black} \\fcolorbox{gold}{yellow} {\u03a9(n)}\\) Average \\(\\color{white} \\fcolorbox{crimson}{firebrick} {\u0398(n^2)}\\) Worst \\(\\color{white} \\fcolorbox{crimson}{firebrick} {O(n^2)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) <p>Simple to implement and sufficient for smaller data sets.</p> <p>Note</p> <p>A work in progress, check back later for more content.</p>"},{"location":"sorting/merge-sort/","title":"Merge sort","text":"<p>Quote</p> <p>\u201cThe art of programming is the art of organizing complexity.\u201d \u2014 Edsger W. Dijkstra</p> Case Time complexity Space complexity Best \\(\\color{black} \\fcolorbox{darkorange}{sandybrown} {\u03a9(n . log(n))}\\) Average \\(\\color{black} \\fcolorbox{darkorange}{sandybrown} {\u0398(n . log(n))}\\) Worst \\(\\color{black} \\fcolorbox{darkorange}{sandybrown} {O(n . log(n))}\\) \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\) <p>Efficiently sorts large data sets with divide and conquer.</p> <p>Note</p> <p>A work in progress, check back later for more content.</p>"},{"location":"sorting/quicksort/","title":"Quicksort","text":"<p>Quote</p> <p>\u201cI call it my billion-dollar mistake. It was the invention of the null reference in 1965.\u201d \u2014 Tony Hoare</p> Case Time complexity Space complexity Best \\(\\color{black} \\fcolorbox{darkorange}{sandybrown} {\u03a9(n . log(n))}\\) Average \\(\\color{black} \\fcolorbox{darkorange}{sandybrown} {\u0398(n . log(n))}\\) Worst \\(\\color{white} \\fcolorbox{crimson}{firebrick} {O(n^2)}\\) \\(\\color{black} \\fcolorbox{yellowgreen}{greenyellow} {O(log(n))}\\) <p>Expands on merge sort with a pivot to reduce the number of comparisons.</p> <p>Note</p> <p>A work in progress, check back later for more content.</p>"},{"location":"sorting/selection-sort/","title":"Selection sort","text":"<p>Quote</p> <p>\u201cIt's hardware that makes a machine fast. It's software that makes a fast machine slow.\u201d \u2014 Craig Bruce</p> Case Time complexity Space complexity Best \\(\\color{white} \\fcolorbox{crimson}{firebrick} {\u03a9(n^2)}\\) Average \\(\\color{white} \\fcolorbox{crimson}{firebrick} {\u0398(n^2)}\\) Worst \\(\\color{white} \\fcolorbox{crimson}{firebrick} {O(n^2)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) <p>Selection sort is easy to implement but performs the worst of them all.</p> GroovyJavaJavaScriptKotlinPythonTypeScript <pre><code>def selectionSort(int[] array) {\n    for (var step = 0; step &lt; array.length - 1; step++) {\n        int minIndex = step\n        for (var i = step + 1; i &lt; array.length; i++) {\n            if (array[i] &lt; array[minIndex]) {\n                minIndex = i\n            }\n        }\n        int temp = array[step]\n        array[step] = array[minIndex]\n        array[minIndex] = temp\n    }\n}\n</code></pre> <pre><code>void selectionSort(int array[]) {\n    for (int step = 0; step &lt; array.length - 1; step++) {\n        int minIndex = step;\n        for (int i = step + 1; i &lt; array.length; i++) {\n            if (array[i] &lt; array[minIndex]) {\n                minIndex = i;\n            }\n        }\n        int temp = array[step];\n        array[step] = array[minIndex];\n        array[minIndex] = temp;\n    }\n}\n</code></pre> <pre><code>function selectionSort(array) {\n  for (let step = 0; step &lt; array.length - 1; step++) {\n    let minIndex = step;\n    for (let i = step + 1; i &lt; array.length; i++) {\n      if (array[i] &lt; array[minIndex]) {\n        minIndex = i;\n      }\n    }\n    let temp = array[step];\n    array[step] = array[minIndex];\n    array[minIndex] = temp;\n  }\n}\n</code></pre> <pre><code>fun selectionSort(array: IntArray) {\n    for (step in 0 until array.lastIndex) {\n        var minIndex = step\n        for (i in step + 1 until array.size) {\n            if (array[i] &lt; array[minIndex]) {\n                minIndex = i\n            }\n        }\n        val temp = array[step]\n        array[step] = array[minIndex]\n        array[minIndex] = temp\n    }\n}\n</code></pre> <pre><code>def selection_sort(array):\n    for step in range(len(array) - 1):\n        min_index = step\n        for i in range(step + 1, len(array)):\n            if array[i] &lt; array[min_index]:\n                min_index = i\n        array[step], array[min_index] = array[min_index], array[step]\n</code></pre> <pre><code>function selectionSort(array: number[]): void {\n  for (let step = 0; step &lt; array.length - 1; step++) {\n    let minIndex = step;\n    for (let i = step + 1; i &lt; array.length; i++) {\n      if (array[i] &lt; array[minIndex]) {\n        minIndex = i;\n      }\n    }\n    let temp = array[step];\n    array[step] = array[minIndex];\n    array[minIndex] = temp;\n  }\n}\n</code></pre> <p></p>"},{"location":"sorting/selection-sort/#use-cases","title":"Use cases","text":"<ul> <li> The list to sort is small</li> <li> It needs to check all elements</li> <li> Swapping elements is okay</li> </ul>"}]}