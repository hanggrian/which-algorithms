{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Which algorithms should I use?","text":"<p>Note</p> <p>A work in progress, check back later for more content.</p> <p>Personal note of programming algorithms and data structures.</p> <ul> <li> <p>Two pointers</p> <p>Sliding window and fast-slow pointers.</p> <p></p> <p> Sliding window  Fast-slow pointers</p> </li> </ul>"},{"location":"two-pointers/","title":"Two pointers","text":"<p>Make use of two pointers to solve problems that require traversing a sequence of elements.</p> <p>Common problems:</p> <ul> <li>Two Sum</li> <li>Container With Most Water</li> <li>Trapping Rain Water</li> </ul> GroovyJavaJavaScriptPythonTypeScript <pre><code>int[] twoSum(int[] nums, int target) {\n    for (var i = 0; i &lt; nums.length; i++) {\n        for (var j = i + 1; j &lt; nums.length; j++) {\n            if (nums[j] == target - nums[i]) {\n                return new int[]{i, j}\n            }\n        }\n    }\n    return null\n}\n</code></pre> <pre><code>int[] twoSum(int[] nums, int target) {\n    for (int i = 0; i &lt; nums.length; i++) {\n        for (int j = i + 1; j &lt; nums.length; j++) {\n            if (nums[j] == target - nums[i]) {\n                return new int[]{i, j};\n            }\n        }\n    }\n    return null;\n}\n</code></pre> <pre><code>function twoSum(nums, target) {\n  for (let i = 0; i &lt; nums.length; i++) {\n    const complement = target - nums[i];\n    if (nums.slice(i + 1).includes(complement)) {\n      return [i, nums.indexOf(complement, i + 1)];\n    }\n  }\n  return undefined;\n}\n</code></pre> <pre><code>def two_sum(self, nums: list[int], target: int) -&gt; list[int] | None:\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in nums[i + 1:]:\n            return [i, nums.index(complement, i + 1)]\n    return None\n</code></pre> <pre><code>function twoSum(nums: number[], target: number): number[] {\n  for (let i = 0; i &lt; nums.length; i++) {\n    const complement = target - nums[i];\n    if (nums.slice(i + 1).includes(complement)) {\n      return [i, nums.indexOf(complement, i + 1)];\n    }\n  }\n  return undefined;\n}\n</code></pre> <p></p>"},{"location":"two-pointers/#sliding-window","title":"Sliding window","text":"<p>Restrict the range of the two pointers to a certain window size or condition.</p> <p>Common problems:</p> <ul> <li>Longest Substring Without Repeating Characters</li> <li>Minimum Window Substring</li> <li>Sliding Window Maximum</li> </ul> GroovyJavaJavaScriptPythonTypeScript <pre><code>int lengthOfLongestSubstring(String s) {\n    if (s.isEmpty()) {\n        return 0\n    }\n    HashSet&lt;Character&gt; characters = []\n    var start = 0\n    var end = 0\n    var maxLength = Integer.MIN_VALUE\n    while (end &lt; s.length()) {\n        if (characters.add(s.charAt(end))) {\n            maxLength = Math.max(maxLength, characters.size())\n            end++\n            continue\n        }\n        characters.remove(s.charAt(start))\n        start++\n    }\n    return maxLength\n}\n</code></pre> <pre><code>int lengthOfLongestSubstring(String s) {\n    int i = 0;\n    int j = 0;\n    int maxLength = Integer.MIN_VALUE;\n    Set&lt;Character&gt; set = new HashSet&lt;&gt;();\n    while (j &lt; s.length()) {\n        if (set.add(s.charAt(j))) {\n            maxLength = Math.max(maxLength, set.size());\n            j++;\n        } else {\n            set.remove(s.charAt(i));\n            i++;\n        }\n    }\n    return maxLength;\n}\n</code></pre> <pre><code>function lengthOfLongestSubstring(s) {\n    if (!s) {\n      return 0;\n    }\n    const characters = new Set();\n    let start = 0;\n    let end = 0;\n    let maxLength = Number.MIN_SAFE_INTEGER;\n    while (end &lt; s.length) {\n      if (!characters.has(s[end])) {\n        characters.add(s[end]);\n        end++;\n        maxLength = Math.max(maxLength, characters.size);\n        continue;\n      }\n      characters.delete(s[start]);\n      start++;\n    }\n    return maxLength;\n  }\n</code></pre> <pre><code>def length_of_longest_substring(self, s: str) -&gt; int:\n    i = 0\n    j = 0\n    max_length = sys.maxsize\n    char_set = set()\n    while j &lt; len(s):\n        if s[j] not in char_set:\n            char_set.add(s[j])\n            max_length = max(max_length, len(char_set))\n            j += 1\n        else:\n            char_set.remove(s[i])\n            i += 1\n    return max_length\n</code></pre> <pre><code>function lengthOfLongestSubstring(s: string): number {\n    if (!s) {\n      return 0;\n    }\n    const characters = new Set&lt;string&gt;();\n    let start = 0;\n    let end = 0;\n    let maxLength = Number.MIN_SAFE_INTEGER;\n    while (end &lt; s.length) {\n      if (!characters.has(s[end])) {\n        characters.add(s[end]);\n        end++;\n        maxLength = Math.max(maxLength, characters.size);\n        continue;\n      }\n      characters.delete(s[start]);\n      start++;\n    }\n    return maxLength;\n  }\n</code></pre> <p></p>"},{"location":"two-pointers/#fast-slow-pointers","title":"Fast-slow pointers","text":"<p>Pointers that move at different speeds to find a cycle or a specific condition.</p> <p>Common problems:</p> <ul> <li>Linked List Cycle</li> <li>Sort List</li> <li>Reorder List</li> </ul> GroovyJavaJavaScriptPythonTypeScript <pre><code>boolean hasCycle(SinglyListNode head) {\n    // visited nodes\n    Set&lt;SinglyListNode&gt; visits = []\n    for (var node : head) {\n        if (!visits.add(node)) {\n            return true\n        }\n    }\n    return false\n}\n</code></pre> <pre><code>boolean hasCycle(ListNode head) {\n    if (head == null || head.next == null) {\n        return false;\n    }\n    ListNode slow = head.next;\n    ListNode fast = head.next.next;\n    while (fast != null &amp;&amp; fast.next != null &amp;&amp; slow != fast) {\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n    return slow == fast;\n}\n</code></pre> <pre><code>function hasCycle(head) {\n  // visited nodes\n  const visits = new Set();\n  for (const node of head) {\n    if (visits.has(node)) {\n      return true;\n    }\n    visits.add(node);\n  }\n  return false;\n}\n</code></pre> <pre><code>def has_cycle(self, head: ListNode) -&gt; bool:\n    if not head or not head.next:\n        return False\n    slow = head.next\n    fast = head.next.next\n    while fast and fast.next and slow != fast:\n        slow = slow.next\n        fast = fast.next.next\n    return slow == fast\n</code></pre> <pre><code>function hasCycle(head: SinglyListNode | undefined): boolean {\n  // visited nodes\n  const visits = new Set&lt;SinglyListNode&gt;();\n  for (const node of head) {\n    if (visits.has(node)) {\n      return true;\n    }\n    visits.add(node);\n  }\n  return false;\n}\n</code></pre> <p></p>"},{"location":"data-structures/","title":"Index","text":"<ul> <li> <p>Lists</p> <p></p> <p>Array, list or any indexed collection of elements.</p> <p> Java  Python</p> </li> <li> <p>Queues</p> <p></p> <p>Queue, stack or any FIFO or LIFO collection of elements.</p> <p> Java  Python</p> </li> <li> <p>Sets</p> <p></p> <p>Set or any collection of unique elements.</p> <p> Java  Python</p> </li> <li> <p>Maps</p> <p></p> <p>Map, dictionary or any collection of key-value pairs.</p> <p> Java  Python</p> </li> </ul>"},{"location":"data-structures/#performance-overview","title":"Performance overview","text":"Data structure Access Search Insert Delete Lists \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {\u0398(1)}\\) \u2192 \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{black} \\fcolorbox{gold}{yellow} {\u0398(n)}\\) \u2192 \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\) \\(\\color{black} \\fcolorbox{gold}{yellow} {\u0398(n)}\\) \u2192 \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\) \\(\\color{black} \\fcolorbox{gold}{yellow} {\u0398(n)}\\) \u2192 \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\) Queues \\(\\color{black} \\fcolorbox{gold}{yellow} {\u0398(n)}\\) \u2192 \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\) \\(\\color{black} \\fcolorbox{gold}{yellow} {\u0398(n)}\\) \u2192 \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {\u0398(1)}\\) \u2192 \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {\u0398(1)}\\) \u2192 \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) Sets \\(\\color{black} \\fcolorbox{gold}{yellow} {\u0398(n)}\\) \u2192 \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\) \\(\\color{black} \\fcolorbox{gold}{yellow} {\u0398(n)}\\) \u2192 \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {\u0398(1)}\\) \u2192 \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {\u0398(1)}\\) \u2192 \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) Maps \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {\u0398(1)}\\) \u2192 \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {\u0398(1)}\\) \u2192 \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {\u0398(1)}\\) \u2192 \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {\u0398(1)}\\) \u2192 \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\)"},{"location":"data-structures/lists/","title":"Lists","text":""},{"location":"data-structures/lists/#java","title":"Java","text":"Operation ArrayList  LinkedList  CopyOnWriteArrayList  Add \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) Remove \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\) \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) Get \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\) Contains \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\) \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\) \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\) Next \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\)"},{"location":"data-structures/lists/#python","title":"Python","text":"Operation list  Copy \\(\\color{black} \\fcolorbox{gold}{yellow} {\u0398(n)}\\) \u2192 \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\) Append \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {\u0398(1)}\\) \u2192 \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) Pop last \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {\u0398(1)}\\) \u2192 \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) Pop intermediate \\(\\color{black} \\fcolorbox{gold}{yellow} {\u0398(n)}\\) \u2192 \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\) Insert \\(\\color{black} \\fcolorbox{gold}{yellow} {\u0398(n)}\\) \u2192 \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\) Get item \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {\u0398(1)}\\) \u2192 \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) Set item \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {\u0398(1)}\\) \u2192 \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) Delete item \\(\\color{black} \\fcolorbox{gold}{yellow} {\u0398(n)}\\) \u2192 \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\) Iteration \\(\\color{black} \\fcolorbox{gold}{yellow} {\u0398(n)}\\) \u2192 \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\) Get slice \\(\\color{black} \\fcolorbox{yellowgreen}{greenyellow} {\u0398(k)}\\) \u2192 \\(\\color{black} \\fcolorbox{yellowgreen}{greenyellow} {O(k)}\\) Del slice \\(\\color{black} \\fcolorbox{gold}{yellow} {\u0398(n)}\\) \u2192 \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\) Set slice \\(\\color{black} \\fcolorbox{yellowgreen}{greenyellow} {\u0398(k + n)}\\) \u2192 \\(\\color{black} \\fcolorbox{yellowgreen}{greenyellow} {O(k + n)}\\) Extend \\(\\color{black} \\fcolorbox{yellowgreen}{greenyellow} {\u0398(k)}\\) \u2192 \\(\\color{black} \\fcolorbox{yellowgreen}{greenyellow} {O(k)}\\) Sort \\(\\color{black} \\fcolorbox{yellowgreen}{greenyellow} {\u0398(log(n))}\\) \u2192 \\(\\color{black} \\fcolorbox{yellowgreen}{greenyellow} {O(log(n))}\\) Multiply \\(\\color{black} \\fcolorbox{yellowgreen}{greenyellow} {\u0398(n . k)}\\) \u2192 \\(\\color{black} \\fcolorbox{yellowgreen}{greenyellow} {O(n . k)}\\) <code>x in s</code> \\(\\color{black} \\fcolorbox{gold}{yellow} {\u0398(n)}\\) <code>mins(s)</code>, <code>max(s)</code> \\(\\color{black} \\fcolorbox{gold}{yellow} {\u0398(n)}\\) Get length \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {\u0398(1)}\\) \u2192 \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\)"},{"location":"data-structures/maps/","title":"Maps","text":""},{"location":"data-structures/maps/#java","title":"Java","text":"Operation HashMap  LinkedHashMap  IdentityHashMap  WeakHashMap  EnumMap  TreeMap  ConcurrentHashMap  ConcurrentSkipListMap  Get \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{black} \\fcolorbox{yellowgreen}{greenyellow} {O(log(n))}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{black} \\fcolorbox{yellowgreen}{greenyellow} {O(log(n))}\\) Contains \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{black} \\fcolorbox{yellowgreen}{greenyellow} {O(log(n))}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{black} \\fcolorbox{yellowgreen}{greenyellow} {O(log(n))}\\) Next \\(\\color{black} \\fcolorbox{yellowgreen}{greenyellow} {O(h / n)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{black} \\fcolorbox{yellowgreen}{greenyellow} {O(h / n)}\\) \\(\\color{black} \\fcolorbox{yellowgreen}{greenyellow} {O(h / n)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{black} \\fcolorbox{yellowgreen}{greenyellow} {O(log(n))}\\) \\(\\color{black} \\fcolorbox{yellowgreen}{greenyellow} {O(h / n)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\)"},{"location":"data-structures/maps/#python","title":"Python","text":"Operation dict  <code>k in d</code> \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {\u0398(1)}\\) \u2192 \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\) Copy \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\) Get item \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {\u0398(1)}\\) \u2192 \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\) Set item \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {\u0398(1)}\\) \u2192 \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\) Delete item \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {\u0398(1)}\\) \u2192 \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\) Iteration \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\)"},{"location":"data-structures/queues/","title":"Queues","text":""},{"location":"data-structures/queues/#java","title":"Java","text":"Operation PriorityQueue  LinkedList  ArrayDequeue  ConcurrentLinkedQueue  ArrayBlockingQueue  PriorityBlockingQueue  SynchronousQueue DelayQueue  LinkedBlockingQueue  Offer \\(\\color{black} \\fcolorbox{yellowgreen}{greenyellow} {O(log(n))}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{black} \\fcolorbox{yellowgreen}{greenyellow} {O(log(n))}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{black} \\fcolorbox{yellowgreen}{greenyellow} {O(log(n))}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) Peek \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) Poll \\(\\color{black} \\fcolorbox{yellowgreen}{greenyellow} {O(log(n))}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{black} \\fcolorbox{yellowgreen}{greenyellow} {O(log(n))}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{black} \\fcolorbox{yellowgreen}{greenyellow} {O(log(n))}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) Remove \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\) \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\) \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\) \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\) \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\) \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\) \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\) Size \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\)"},{"location":"data-structures/queues/#python","title":"Python","text":"Operation collections.deque  Copy \\(\\color{black} \\fcolorbox{gold}{yellow} {\u0398(n)}\\) \u2192 \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\) Append \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {\u0398(1)}\\) \u2192 \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) Append left \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {\u0398(1)}\\) \u2192 \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) Pop \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {\u0398(1)}\\) \u2192 \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) Pop left \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {\u0398(1)}\\) \u2192 \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) Extend \\(\\color{black} \\fcolorbox{yellowgreen}{greenyellow} {\u0398(k)}\\) \u2192 \\(\\color{black} \\fcolorbox{yellowgreen}{greenyellow} {O(k)}\\) Extend left \\(\\color{black} \\fcolorbox{yellowgreen}{greenyellow} {\u0398(k)}\\) \u2192 \\(\\color{black} \\fcolorbox{yellowgreen}{greenyellow} {O(k)}\\) Rotate \\(\\color{black} \\fcolorbox{yellowgreen}{greenyellow} {\u0398(k)}\\) \u2192 \\(\\color{black} \\fcolorbox{yellowgreen}{greenyellow} {O(k)}\\) Remove \\(\\color{black} \\fcolorbox{gold}{yellow} {\u0398(n)}\\) \u2192 \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\) Get length \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {\u0398(1)}\\) \u2192 \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\)"},{"location":"data-structures/sets/","title":"Sets","text":""},{"location":"data-structures/sets/#java","title":"Java","text":"Operation HashSet  LinkedHashSet  EnumSet  TreeSet  CopyOnWriteArraySet  ConcurrentSkipListSet  Add \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{black} \\fcolorbox{yellowgreen}{greenyellow} {O(log(n))}\\) \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\) \\(\\color{black} \\fcolorbox{yellowgreen}{greenyellow} {O(log(n))}\\) Remove \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{black} \\fcolorbox{yellowgreen}{greenyellow} {O(log(n))}\\) \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\) \\(\\color{black} \\fcolorbox{yellowgreen}{greenyellow} {O(log(n))}\\) Contains \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{black} \\fcolorbox{yellowgreen}{greenyellow} {O(log(n))}\\) \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\) \\(\\color{black} \\fcolorbox{yellowgreen}{greenyellow} {O(log(n))}\\) Next \\(\\color{black} \\fcolorbox{yellowgreen}{greenyellow} {O(h / n)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{black} \\fcolorbox{yellowgreen}{greenyellow} {O(log(n))}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) Size \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\)"},{"location":"data-structures/sets/#python","title":"Python","text":"Operation set  <code>x in s</code> \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {\u0398(1)}\\) \u2192 \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\) Union <code>s|t</code> \\(\\color{black} \\fcolorbox{gold}{yellow} {\u0398(len(s) + len(t))}\\) Intersection <code>s&amp;t</code> \\(\\color{black} \\fcolorbox{gold}{yellow} {\u0398(min(len(s), len(t)))}\\) \u2192 \\(\\color{black} \\fcolorbox{darkorange}{sandybrown} {O(len(s) . len(t))}\\) Multiple intersection <code>s1&amp;s2&amp;...&amp;sn</code> \\(\\color{black} \\fcolorbox{darkorange}{sandybrown} {(n - 1) . O(l)}\\)\\(\\small{\\textsf{where} l = \\mathtt{max}(\\mathtt{len}(s1), \\ldots, \\mathtt{len}(sn))}\\) Difference <code>s-t</code> \\(\\color{black} \\fcolorbox{gold}{yellow} {\u0398(len(s))}\\) <code>s.difference_update(t)</code> \\(\\color{black} \\fcolorbox{gold}{yellow} {\u0398(len(t))}\\) Symmetric Difference <code>s^t</code> \\(\\color{black} \\fcolorbox{gold}{yellow} {\u0398(len(s))}\\) \u2192 \\(\\color{black} \\fcolorbox{darkorange}{sandybrown} {O(len(s) . len(t))}\\) <code>s.symmetric_difference_update(t)</code> \\(\\color{black} \\fcolorbox{gold}{yellow} {\u0398(len(t))}\\) \u2192 \\(\\color{black} \\fcolorbox{darkorange}{sandybrown} {O(len(s) . len(t))}\\)"},{"location":"searching/","title":"Index","text":"<ul> <li> <p>Linear search </p> <p></p> <p>Linear search or sequential search, iterates through each element until item is found.</p> </li> <li> <p>Binary search </p> <p></p> <p>Binary search or logarithmic search, finds the center position to divide the array into two halves.</p> </li> </ul>"},{"location":"searching/#performance-overview","title":"Performance overview","text":"Search Time complexity Space complexity Linear search \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {\u03a9(1)}\\) \u2192 \\(\\color{black} \\fcolorbox{gold}{yellow} {\u0398(n)}\\) \u2192 \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) Binary search \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {\u03a9(1)}\\) \u2192 \\(\\color{black} \\fcolorbox{yellowgreen}{greenyellow} {\u0398(log(n))}\\) \u2192 \\(\\color{black} \\fcolorbox{yellowgreen}{greenyellow} {O(log(n))}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\)"},{"location":"sorting/","title":"Index","text":"<ul> <li> <p>Selection sort </p> <p></p> <p>Easy to implement but performs the worst of them all.</p> </li> <li> <p>Bubble sort </p> <p></p> <p>Bubble sort or sinking sort, is better than selection sort but more complex than insertion sort.</p> </li> <li> <p>Insertion sort </p> <p></p> <p>Simple to implement and sufficient for smaller data sets.</p> </li> <li> <p>Merge sort </p> <p></p> <p>Efficiently sorts large data sets with divide and conquer.</p> </li> <li> <p>Quicksort </p> <p></p> <p>Expands on merge sort with a pivot to reduce the number of comparisons.</p> </li> <li> <p>Heapsort </p> <p></p> <p>Reorganizes the data into a heap structure to sort it.</p> </li> </ul>"},{"location":"sorting/#performance-overview","title":"Performance overview","text":"Sort Time complexity Space complexity Selection sort \\(\\color{white} \\fcolorbox{crimson}{firebrick} {\u03a9(n^2)}\\) \u2192 \\(\\color{white} \\fcolorbox{crimson}{firebrick} {\u0398(n^2)}\\) \u2192 \\(\\color{white} \\fcolorbox{crimson}{firebrick} {O(n^2)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) Bubble sort \\(\\color{black} \\fcolorbox{gold}{yellow} {\u03a9(n)}\\) \u2192 \\(\\color{white} \\fcolorbox{crimson}{firebrick} {\u0398(n^2)}\\) \u2192 \\(\\color{white} \\fcolorbox{crimson}{firebrick} {O(n^2)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) Insertion sort \\(\\color{black} \\fcolorbox{gold}{yellow} {\u03a9(n)}\\) \u2192 \\(\\color{white} \\fcolorbox{crimson}{firebrick} {\u0398(n^2)}\\) \u2192 \\(\\color{white} \\fcolorbox{crimson}{firebrick} {O(n^2)}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\) Merge sort \\(\\color{black} \\fcolorbox{darkorange}{sandybrown} {\u03a9(n . log(n))}\\) \u2192 \\(\\color{black} \\fcolorbox{darkorange}{sandybrown} {\u0398(n . log(n))}\\) \u2192 \\(\\color{black} \\fcolorbox{darkorange}{sandybrown} {O(n . log(n))}\\) \\(\\color{black} \\fcolorbox{gold}{yellow} {O(n)}\\) Quicksort \\(\\color{black} \\fcolorbox{darkorange}{sandybrown} {\u03a9(n . log(n))}\\) \u2192 \\(\\color{black} \\fcolorbox{darkorange}{sandybrown} {\u0398(n . log(n))}\\) \u2192 \\(\\color{white} \\fcolorbox{crimson}{firebrick} {O(n^2)}\\) \\(\\color{black} \\fcolorbox{yellowgreen}{greenyellow} {O(log(n))}\\) Heapsort \\(\\color{black} \\fcolorbox{darkorange}{sandybrown} {\u03a9(n . log(n))}\\) \u2192 \\(\\color{black} \\fcolorbox{darkorange}{sandybrown} {\u0398(n . log(n))}\\) \u2192 \\(\\color{black} \\fcolorbox{darkorange}{sandybrown} {O(n . log(n))}\\) \\(\\color{white} \\fcolorbox{limegreen}{forestgreen} {O(1)}\\)"}]}